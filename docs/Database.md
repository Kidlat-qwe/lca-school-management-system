-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.announcement_readstbl
(
    announcement_read_id serial NOT NULL,
    announcement_id integer NOT NULL,
    user_id integer NOT NULL,
    read_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT announcement_readstbl_pkey PRIMARY KEY (announcement_read_id),
    CONSTRAINT announcement_readstbl_unique_user_announcement UNIQUE (announcement_id, user_id)
);

COMMENT ON TABLE public.announcement_readstbl
    IS 'Tracks which announcements have been read by which users. Used for notification system.';

COMMENT ON COLUMN public.announcement_readstbl.announcement_id
    IS 'Reference to the announcement';

COMMENT ON COLUMN public.announcement_readstbl.user_id
    IS 'Reference to the user who read the announcement';

COMMENT ON COLUMN public.announcement_readstbl.read_at
    IS 'Timestamp when the announcement was marked as read';

CREATE TABLE IF NOT EXISTS public.announcementstbl
(
    announcement_id serial NOT NULL,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    body text COLLATE pg_catalog."default" NOT NULL,
    recipient_groups text[] COLLATE pg_catalog."default" NOT NULL DEFAULT ARRAY[]::text[],
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Active'::character varying,
    priority character varying(50) COLLATE pg_catalog."default" DEFAULT 'Medium'::character varying,
    branch_id integer,
    created_by integer NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    start_date date,
    end_date date,
    CONSTRAINT announcementstbl_pkey PRIMARY KEY (announcement_id)
);

COMMENT ON TABLE public.announcementstbl
    IS 'Stores school announcements that can be displayed to different user groups (Students, Teachers, Parents, etc.)';

COMMENT ON COLUMN public.announcementstbl.title
    IS 'Title of the announcement';

COMMENT ON COLUMN public.announcementstbl.body
    IS 'Main content/body of the announcement';

COMMENT ON COLUMN public.announcementstbl.recipient_groups
    IS 'Array of recipient groups: All, Students, Teachers, Parents, Admin, Finance. Multiple groups can be selected.';

COMMENT ON COLUMN public.announcementstbl.status
    IS 'Status: Active (visible), Inactive (hidden), Draft (not published)';

COMMENT ON COLUMN public.announcementstbl.priority
    IS 'Priority level: High, Medium, Low. Used for sorting and highlighting important announcements.';

COMMENT ON COLUMN public.announcementstbl.branch_id
    IS 'Branch ID. NULL means announcement applies to all branches, specific ID means branch-specific announcement.';

COMMENT ON COLUMN public.announcementstbl.created_by
    IS 'User ID who created the announcement';

COMMENT ON COLUMN public.announcementstbl.start_date
    IS 'Optional start date. Announcement will only be visible after this date. NULL means visible immediately.';

COMMENT ON COLUMN public.announcementstbl.end_date
    IS 'Optional end date. Announcement will be hidden after this date. NULL means no expiration.';

CREATE TABLE IF NOT EXISTS public.attendancetbl
(
    attendance_id serial NOT NULL,
    classsession_id integer NOT NULL,
    student_id integer NOT NULL,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Present'::character varying,
    notes text COLLATE pg_catalog."default",
    marked_by integer,
    marked_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT attendancetbl_pkey PRIMARY KEY (attendance_id),
    CONSTRAINT attendancetbl_unique_session_student UNIQUE (classsession_id, student_id)
);

COMMENT ON TABLE public.attendancetbl
    IS 'Tracks student attendance for individual class sessions. One record per student per session.';

COMMENT ON COLUMN public.attendancetbl.classsession_id
    IS 'Reference to the specific class session';

COMMENT ON COLUMN public.attendancetbl.student_id
    IS 'Reference to the student';

COMMENT ON COLUMN public.attendancetbl.status
    IS 'Attendance status: Present, Absent, Late, Excused';

COMMENT ON COLUMN public.attendancetbl.notes
    IS 'Optional notes about the attendance (e.g., reason for absence)';

COMMENT ON COLUMN public.attendancetbl.marked_by
    IS 'User ID who marked the attendance';

COMMENT ON COLUMN public.attendancetbl.marked_at
    IS 'Timestamp when attendance was marked';

CREATE TABLE IF NOT EXISTS public.branchestbl
(
    branch_id serial NOT NULL,
    branch_email character varying(255) COLLATE pg_catalog."default",
    branch_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    branch_address text COLLATE pg_catalog."default",
    branch_phone_number character varying(50) COLLATE pg_catalog."default",
    status character varying(50) COLLATE pg_catalog."default",
    city character varying(100) COLLATE pg_catalog."default",
    postal_code character varying(20) COLLATE pg_catalog."default",
    business_registration_number character varying(100) COLLATE pg_catalog."default",
    registered_tax_id character varying(100) COLLATE pg_catalog."default",
    establishment_date date,
    country character varying(100) COLLATE pg_catalog."default",
    state_province_region character varying(100) COLLATE pg_catalog."default",
    locale character varying(10) COLLATE pg_catalog."default",
    currency character varying(10) COLLATE pg_catalog."default" DEFAULT 'PHP'::character varying,
    CONSTRAINT branchestbl_pkey PRIMARY KEY (branch_id),
    CONSTRAINT branchestbl_branch_email_key UNIQUE (branch_email)
);

CREATE TABLE IF NOT EXISTS public.class_merge_historytbl
(
    merge_history_id serial NOT NULL,
    merged_class_id integer NOT NULL,
    merged_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    merged_by integer,
    merge_data jsonb NOT NULL,
    is_undone boolean DEFAULT false,
    undone_at timestamp without time zone,
    undone_by integer,
    CONSTRAINT class_merge_historytbl_pkey PRIMARY KEY (merge_history_id)
);

COMMENT ON TABLE public.class_merge_historytbl
    IS 'Stores complete snapshots of class merge operations for undo functionality. Contains original classes, enrollments, schedules, reservations, and teacher associations.';

COMMENT ON COLUMN public.class_merge_historytbl.merged_class_id
    IS 'The resulting merged class ID after merge operation';

COMMENT ON COLUMN public.class_merge_historytbl.merged_by
    IS 'User ID who performed the merge operation';

COMMENT ON COLUMN public.class_merge_historytbl.merge_data
    IS 'JSONB snapshot containing: original_classes, original_enrollments, original_schedules, original_reservations, original_teacher_associations';

COMMENT ON COLUMN public.class_merge_historytbl.is_undone
    IS 'Whether this merge has been undone';

COMMENT ON COLUMN public.class_merge_historytbl.undone_by
    IS 'User ID who undid the merge operation';

CREATE TABLE IF NOT EXISTS public.classestbl
(
    class_id serial NOT NULL,
    branch_id integer,
    room_id integer,
    program_id integer,
    level_tag character varying(100) COLLATE pg_catalog."default",
    class_name character varying(100) COLLATE pg_catalog."default",
    max_students integer,
    start_date date,
    end_date date,
    teacher_id integer,
    phase_number integer,
    session_number integer,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Active'::character varying,
    CONSTRAINT classestbl_pkey PRIMARY KEY (class_id)
);

COMMENT ON COLUMN public.classestbl.class_name
    IS 'The name of the class (e.g., "Morning Class", "Section A")';

CREATE TABLE IF NOT EXISTS public.classsessionstbl
(
    classsession_id serial NOT NULL,
    class_id integer NOT NULL,
    phasesessiondetail_id integer,
    phase_number integer NOT NULL,
    phase_session_number integer NOT NULL,
    scheduled_date date NOT NULL,
    scheduled_start_time time without time zone NOT NULL,
    scheduled_end_time time without time zone NOT NULL,
    original_teacher_id integer,
    assigned_teacher_id integer,
    substitute_teacher_id integer,
    substitute_reason text COLLATE pg_catalog."default",
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Scheduled'::character varying,
    actual_date date,
    actual_start_time time without time zone,
    actual_end_time time without time zone,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    suspension_id integer,
    class_code character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT classsessionstbl_pkey PRIMARY KEY (classsession_id),
    CONSTRAINT classsessionstbl_unique_session UNIQUE (class_id, phase_number, phase_session_number, scheduled_date)
);

COMMENT ON COLUMN public.classsessionstbl.suspension_id
    IS 'Reference to suspension period if this session was cancelled due to a suspension';

COMMENT ON COLUMN public.classsessionstbl.class_code
    IS 'Auto-generated unique class code per session in format: {program_code}_{MMDDYY}_{HHMM}{AM/PM}_{ClassName}. Example: pk_121525_1000AM_Bees for Session 1, pk_121625_0800AM_Bees for Session 2, etc.';

CREATE TABLE IF NOT EXISTS public.classstudentstbl
(
    classstudent_id serial NOT NULL,
    student_id integer,
    class_id integer,
    enrolled_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    enrolled_by character varying(255) COLLATE pg_catalog."default",
    phase_number integer,
    enrollment_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'Active'::character varying,
    removed_at timestamp without time zone,
    removed_reason text COLLATE pg_catalog."default",
    removed_by character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT classstudentstbl_pkey PRIMARY KEY (classstudent_id)
);

COMMENT ON COLUMN public.classstudentstbl.phase_number
    IS 'The phase number the student is enrolled in for this class. Automatically determined based on class start date and current phase.';

CREATE TABLE IF NOT EXISTS public.classteacherstbl
(
    classteacher_id serial NOT NULL,
    class_id integer NOT NULL,
    teacher_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT classteacherstbl_pkey PRIMARY KEY (classteacher_id),
    CONSTRAINT classteacherstbl_class_id_teacher_id_key UNIQUE (class_id, teacher_id)
);

CREATE TABLE IF NOT EXISTS public.curriculumstbl
(
    curriculum_id serial NOT NULL,
    curriculum_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    number_of_phase integer,
    number_of_session_per_phase integer,
    status character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT curriculumstbl_pkey PRIMARY KEY (curriculum_id)
);

CREATE TABLE IF NOT EXISTS public.guardianstbl
(
    guardian_id serial NOT NULL,
    student_id integer,
    email character varying(255) COLLATE pg_catalog."default",
    guardian_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    relationship character varying(50) COLLATE pg_catalog."default",
    guardian_phone_number character varying(50) COLLATE pg_catalog."default",
    gender character varying(50) COLLATE pg_catalog."default",
    address text COLLATE pg_catalog."default",
    city character varying(100) COLLATE pg_catalog."default",
    postal_code character varying(20) COLLATE pg_catalog."default",
    country character varying(100) COLLATE pg_catalog."default",
    state_province_region character varying(100) COLLATE pg_catalog."default",
    CONSTRAINT guardianstbl_pkey PRIMARY KEY (guardian_id)
);

CREATE TABLE IF NOT EXISTS public.installmentinvoiceprofilestbl
(
    installmentinvoiceprofiles_id serial NOT NULL,
    student_id integer,
    branch_id integer,
    package_id integer,
    amount numeric(10, 2) NOT NULL,
    frequency character varying(50) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    day_of_month integer,
    is_active boolean DEFAULT true,
    bill_invoice_due_date date,
    next_invoice_due_date date,
    first_billing_month date,
    first_generation_date date,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_by character varying(255) COLLATE pg_catalog."default",
    class_id integer,
    total_phases integer,
    generated_count integer DEFAULT 0,
    downpayment_paid boolean DEFAULT false,
    downpayment_invoice_id integer,
    CONSTRAINT installmentinvoiceprofilestbl_pkey PRIMARY KEY (installmentinvoiceprofiles_id)
);

COMMENT ON COLUMN public.installmentinvoiceprofilestbl.class_id
    IS 'The class the student is enrolled in. Used to determine total phases from curriculum.';

COMMENT ON COLUMN public.installmentinvoiceprofilestbl.total_phases
    IS 'Total number of phases in the curriculum. Determines how many invoices should be generated.';

COMMENT ON COLUMN public.installmentinvoiceprofilestbl.generated_count
    IS 'Number of invoices generated so far. Generation stops when this reaches total_phases.';

COMMENT ON COLUMN public.installmentinvoiceprofilestbl.downpayment_paid
    IS 'Indicates whether the downpayment invoice has been paid. Installment invoices will only be generated when this is true.';

COMMENT ON COLUMN public.installmentinvoiceprofilestbl.downpayment_invoice_id
    IS 'Reference to the downpayment invoice. Used to track when downpayment is paid.';

CREATE TABLE IF NOT EXISTS public.installmentinvoicestbl
(
    installmentinvoicedtl_id serial NOT NULL,
    installmentinvoiceprofiles_id integer,
    scheduled_date date,
    status character varying(50) COLLATE pg_catalog."default",
    student_name character varying(255) COLLATE pg_catalog."default",
    total_amount_including_tax numeric(10, 2),
    total_amount_excluding_tax numeric(10, 2),
    frequency character varying(50) COLLATE pg_catalog."default",
    next_generation_date date,
    next_invoice_month date,
    CONSTRAINT installmentinvoicestbl_pkey PRIMARY KEY (installmentinvoicedtl_id)
);

CREATE TABLE IF NOT EXISTS public.invoiceitemstbl
(
    invoice_item_id serial NOT NULL,
    invoice_id integer,
    description character varying(255) COLLATE pg_catalog."default",
    amount numeric(10, 2),
    tax_item character varying(255) COLLATE pg_catalog."default",
    tax_percentage numeric(5, 2),
    discount_amount numeric(10, 2),
    penalty_amount numeric(10, 2),
    CONSTRAINT invoiceitemstbl_pkey PRIMARY KEY (invoice_item_id)
);

CREATE TABLE IF NOT EXISTS public.invoicestbl
(
    invoice_id serial NOT NULL,
    invoice_description character varying(255) COLLATE pg_catalog."default",
    branch_id integer,
    amount numeric(10, 2),
    status character varying(50) COLLATE pg_catalog."default",
    remarks text COLLATE pg_catalog."default",
    issue_date date,
    due_date date,
    created_by integer,
    installmentinvoiceprofiles_id integer,
    package_id integer,
    promo_id integer,
    late_penalty_applied_for_due_date date,
    CONSTRAINT invoicestbl_pkey PRIMARY KEY (invoice_id)
);

COMMENT ON COLUMN public.invoicestbl.installmentinvoiceprofiles_id
    IS 'Links invoice to installment invoice profile. Used to track installment payments and auto-progress student phases.';

COMMENT ON COLUMN public.invoicestbl.package_id
    IS 'Links invoice to package. Used to track which package was used, especially for promo package student limit tracking.';

COMMENT ON COLUMN public.invoicestbl.promo_id
    IS 'Links invoice to promo that was applied. Used to track promo usage and discounts.';

CREATE TABLE IF NOT EXISTS public.invoicestudentstbl
(
    invoice_student_id serial NOT NULL,
    invoice_id integer,
    student_id integer,
    CONSTRAINT invoicestudentstbl_pkey PRIMARY KEY (invoice_student_id)
);

CREATE TABLE IF NOT EXISTS public.merchandiserequestlogtbl
(
    request_id serial NOT NULL,
    merchandise_id integer,
    requested_by integer NOT NULL,
    requested_branch_id integer NOT NULL,
    merchandise_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    size character varying(50) COLLATE pg_catalog."default",
    requested_quantity integer NOT NULL,
    request_reason text COLLATE pg_catalog."default",
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Pending'::character varying,
    reviewed_by integer,
    reviewed_at timestamp without time zone,
    review_notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    gender character varying(20) COLLATE pg_catalog."default",
    type character varying(30) COLLATE pg_catalog."default",
    CONSTRAINT merchandiserequestlogtbl_pkey PRIMARY KEY (request_id)
);

COMMENT ON TABLE public.merchandiserequestlogtbl
    IS 'Tracks merchandise stock requests from Admins to Superadmins. Admins request stock when inventory is low, Superadmins approve or reject requests.';

COMMENT ON COLUMN public.merchandiserequestlogtbl.merchandise_id
    IS 'Reference to existing merchandise. NULL if requesting new merchandise not yet in branch catalog.';

COMMENT ON COLUMN public.merchandiserequestlogtbl.requested_by
    IS 'Admin user who made the request';

COMMENT ON COLUMN public.merchandiserequestlogtbl.requested_branch_id
    IS 'Branch requesting the merchandise stock';

COMMENT ON COLUMN public.merchandiserequestlogtbl.merchandise_name
    IS 'Name of merchandise being requested (preserved even if merchandise is deleted)';

COMMENT ON COLUMN public.merchandiserequestlogtbl.size
    IS 'Size of merchandise being requested (e.g., S, M, L, XL)';

COMMENT ON COLUMN public.merchandiserequestlogtbl.requested_quantity
    IS 'Quantity of merchandise being requested';

COMMENT ON COLUMN public.merchandiserequestlogtbl.request_reason
    IS 'Reason for the stock request (e.g., "Low stock", "High demand", "New merchandise needed")';

COMMENT ON COLUMN public.merchandiserequestlogtbl.status
    IS 'Request status: Pending (awaiting review), Approved (approved by superadmin), Rejected (rejected by superadmin), Cancelled (cancelled by admin)';

COMMENT ON COLUMN public.merchandiserequestlogtbl.reviewed_by
    IS 'Superadmin who reviewed (approved/rejected) the request';

COMMENT ON COLUMN public.merchandiserequestlogtbl.reviewed_at
    IS 'Timestamp when request was reviewed';

COMMENT ON COLUMN public.merchandiserequestlogtbl.review_notes
    IS 'Notes from superadmin about approval/rejection';

CREATE TABLE IF NOT EXISTS public.merchandisestbl
(
    merchandise_id serial NOT NULL,
    merchandise_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    size character varying(50) COLLATE pg_catalog."default",
    quantity integer,
    price numeric(10, 2),
    branch_id integer,
    image_url character varying(500) COLLATE pg_catalog."default",
    gender character varying(20) COLLATE pg_catalog."default",
    type character varying(30) COLLATE pg_catalog."default",
    CONSTRAINT merchandisestbl_pkey PRIMARY KEY (merchandise_id)
);

COMMENT ON COLUMN public.merchandisestbl.image_url
    IS 'URL to merchandise image stored in Supabase storage. Used for displaying merchandise in card-based UI.';

CREATE TABLE IF NOT EXISTS public.packagedetailstbl
(
    packagedtl_id serial NOT NULL,
    package_id integer,
    pricinglist_id integer,
    merchandise_id integer,
    is_included boolean DEFAULT true,
    CONSTRAINT packagedetailstbl_pkey PRIMARY KEY (packagedtl_id)
);

CREATE TABLE IF NOT EXISTS public.packagestbl
(
    package_id serial NOT NULL,
    package_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    branch_id integer,
    status character varying(50) COLLATE pg_catalog."default",
    package_price numeric(10, 2),
    level_tag character varying(100) COLLATE pg_catalog."default",
    package_type character varying(50) COLLATE pg_catalog."default" DEFAULT 'Fullpayment'::character varying,
    phase_start integer,
    phase_end integer,
    downpayment_amount numeric(10, 2) DEFAULT NULL::numeric,
    CONSTRAINT packagestbl_pkey PRIMARY KEY (package_id)
);

COMMENT ON COLUMN public.packagestbl.downpayment_amount
    IS 'Downpayment amount required before starting installment invoices. Only applicable for Installment package type.';

CREATE TABLE IF NOT EXISTS public.paymenttbl
(
    payment_id serial NOT NULL,
    invoice_id integer NOT NULL,
    student_id integer NOT NULL,
    branch_id integer,
    payment_method character varying(50) COLLATE pg_catalog."default" NOT NULL,
    payment_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    payable_amount numeric(10, 2) NOT NULL,
    issue_date date NOT NULL,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Completed'::character varying,
    reference_number character varying(255) COLLATE pg_catalog."default",
    remarks text COLLATE pg_catalog."default",
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT paymenttbl_pkey PRIMARY KEY (payment_id)
);

CREATE TABLE IF NOT EXISTS public.phasesessionstbl
(
    phasesessiondetail_id serial NOT NULL,
    curriculum_id integer,
    phase_number integer,
    phase_session_number integer,
    topic character varying(255) COLLATE pg_catalog."default",
    goal text COLLATE pg_catalog."default",
    agenda text COLLATE pg_catalog."default",
    CONSTRAINT phasesessionstbl_pkey PRIMARY KEY (phasesessiondetail_id)
);

CREATE TABLE IF NOT EXISTS public.pricingliststbl
(
    pricinglist_id serial NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    level_tag character varying(50) COLLATE pg_catalog."default",
    price numeric(10, 2),
    branch_id integer,
    CONSTRAINT pricingliststbl_pkey PRIMARY KEY (pricinglist_id)
);

CREATE TABLE IF NOT EXISTS public.programstbl
(
    program_id serial NOT NULL,
    program_code character varying(50) COLLATE pg_catalog."default",
    program_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    curriculum_id integer,
    session_duration_hours numeric(4, 2),
    CONSTRAINT programstbl_pkey PRIMARY KEY (program_id),
    CONSTRAINT programstbl_program_code_key UNIQUE (program_code)
);

COMMENT ON COLUMN public.programstbl.session_duration_hours
    IS 'Fixed session duration in hours for all sessions in this program. Used to auto-calculate session end times from start times.';

CREATE TABLE IF NOT EXISTS public.promomerchandisetbl
(
    promomerchandise_id serial NOT NULL,
    promo_id integer NOT NULL,
    merchandise_id integer NOT NULL,
    quantity integer DEFAULT 1,
    CONSTRAINT promomerchandisetbl_pkey PRIMARY KEY (promomerchandise_id)
);

COMMENT ON TABLE public.promomerchandisetbl
    IS 'Stores free merchandise items included in promos';

COMMENT ON COLUMN public.promomerchandisetbl.quantity
    IS 'How many of this item to give for free';

CREATE TABLE IF NOT EXISTS public.promopackagestbl
(
    promopackage_id serial NOT NULL,
    promo_id integer NOT NULL,
    package_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT promopackagestbl_pkey PRIMARY KEY (promopackage_id),
    CONSTRAINT promopackagestbl_unique_promo_package UNIQUE (promo_id, package_id)
);

COMMENT ON TABLE public.promopackagestbl
    IS 'Junction table for many-to-many relationship between promos and packages. Allows one promo to apply to multiple packages.';

COMMENT ON COLUMN public.promopackagestbl.promo_id
    IS 'Reference to the promo';

COMMENT ON COLUMN public.promopackagestbl.package_id
    IS 'Reference to the package that this promo applies to';

CREATE TABLE IF NOT EXISTS public.promostbl
(
    promo_id serial NOT NULL,
    promo_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    package_id integer NOT NULL,
    branch_id integer,
    promo_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    discount_percentage numeric(5, 2),
    discount_amount numeric(10, 2),
    min_payment_amount numeric(10, 2),
    start_date date NOT NULL,
    end_date date NOT NULL,
    max_uses integer,
    current_uses integer DEFAULT 0,
    eligibility_type character varying(50) COLLATE pg_catalog."default" DEFAULT 'all'::character varying,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Active'::character varying,
    description text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_by integer,
    promo_code character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT promostbl_pkey PRIMARY KEY (promo_id)
);

COMMENT ON TABLE public.promostbl
    IS 'Stores promotional offers that can be applied to packages';

COMMENT ON COLUMN public.promostbl.branch_id
    IS 'NULL = all branches, specific ID = branch-specific promo';

COMMENT ON COLUMN public.promostbl.promo_type
    IS 'Type: percentage_discount, fixed_discount, free_merchandise, or combined';

COMMENT ON COLUMN public.promostbl.max_uses
    IS 'Maximum number of students who can avail (NULL = unlimited)';

COMMENT ON COLUMN public.promostbl.eligibility_type
    IS 'all, new_students_only, existing_students_only, or referral_only';

COMMENT ON COLUMN public.promostbl.promo_code
    IS 'Optional promo code for redemption. NULL = auto-apply promo, set value = requires code entry for redemption';

CREATE TABLE IF NOT EXISTS public.promousagetbl
(
    promousage_id serial NOT NULL,
    promo_id integer NOT NULL,
    student_id integer NOT NULL,
    invoice_id integer NOT NULL,
    used_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    discount_applied numeric(10, 2),
    CONSTRAINT promousagetbl_pkey PRIMARY KEY (promousage_id),
    CONSTRAINT promousagetbl_unique_student_promo UNIQUE (promo_id, student_id)
);

COMMENT ON TABLE public.promousagetbl
    IS 'Tracks which students have used which promos';

COMMENT ON COLUMN public.promousagetbl.discount_applied
    IS 'Actual discount amount applied to the invoice';

CREATE TABLE IF NOT EXISTS public.referralstbl
(
    referral_id serial NOT NULL,
    referrer_student_id integer NOT NULL,
    referred_student_id integer NOT NULL,
    referral_code character varying(50) COLLATE pg_catalog."default",
    referred_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Pending'::character varying,
    CONSTRAINT referralstbl_pkey PRIMARY KEY (referral_id),
    CONSTRAINT referralstbl_unique_referred UNIQUE (referred_student_id)
);

COMMENT ON TABLE public.referralstbl
    IS 'Tracks student referrals for promo eligibility';

COMMENT ON COLUMN public.referralstbl.status
    IS 'Pending, Verified, or Used';

CREATE TABLE IF NOT EXISTS public.reservedstudentstbl
(
    reserved_id serial NOT NULL,
    student_id integer NOT NULL,
    class_id integer NOT NULL,
    package_id integer,
    branch_id integer,
    reservation_fee numeric(10, 2),
    status character varying(50) COLLATE pg_catalog."default" DEFAULT 'Reserved'::character varying,
    reserved_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    reserved_by character varying(255) COLLATE pg_catalog."default",
    reservation_fee_paid_at timestamp without time zone,
    upgraded_at timestamp without time zone,
    upgraded_by character varying(255) COLLATE pg_catalog."default",
    notes text COLLATE pg_catalog."default",
    invoice_id integer,
    phase_number integer,
    due_date date,
    expired_at timestamp without time zone,
    CONSTRAINT reservedstudentstbl_pkey PRIMARY KEY (reserved_id),
    CONSTRAINT reservedstudentstbl_student_class_phase_unique UNIQUE (student_id, class_id, phase_number)
);

COMMENT ON TABLE public.reservedstudentstbl
    IS 'Tracks student reservations for classes. Students can reserve a spot by paying a reservation fee, then upgrade to full enrollment.';

COMMENT ON COLUMN public.reservedstudentstbl.status
    IS 'Status: Reserved (initial), Fee Paid (reservation fee paid), Upgraded (converted to enrollment), Cancelled, Expired (payment not made by due date)';

COMMENT ON COLUMN public.reservedstudentstbl.invoice_id
    IS 'Link to the invoice for reservation fee payment';

COMMENT ON COLUMN public.reservedstudentstbl.phase_number
    IS 'Phase number for per-phase reservation. NULL means entire class reservation, specific number means reservation for that phase only.';

COMMENT ON COLUMN public.reservedstudentstbl.due_date
    IS 'Payment due date for reservation fee. If payment is not made by this date, reservation will be automatically expired.';

COMMENT ON COLUMN public.reservedstudentstbl.expired_at
    IS 'Timestamp when reservation was expired due to non-payment. NULL if not expired.';

CREATE TABLE IF NOT EXISTS public.roomschedtbl
(
    class_id integer NOT NULL,
    room_id integer NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    day_of_week character varying(20) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT roomschedtbl_pkey PRIMARY KEY (class_id, room_id, day_of_week)
);

CREATE TABLE IF NOT EXISTS public.roomstbl
(
    room_id serial NOT NULL,
    branch_id integer,
    room_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT roomstbl_pkey PRIMARY KEY (room_id)
);

CREATE TABLE IF NOT EXISTS public.suspensionperiodstbl
(
    suspension_id serial NOT NULL,
    suspension_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    branch_id integer,
    start_date date NOT NULL,
    end_date date NOT NULL,
    reason character varying(100) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    status character varying(20) COLLATE pg_catalog."default" NOT NULL DEFAULT 'Active'::character varying,
    affected_class_ids integer[],
    auto_reschedule boolean DEFAULT true,
    created_by integer NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT suspensionperiodstbl_pkey PRIMARY KEY (suspension_id)
);

COMMENT ON TABLE public.suspensionperiodstbl
    IS 'Tracks suspension periods for classes due to calamities, holidays, or other events. Enables bulk cancellation and automatic rescheduling.';

COMMENT ON COLUMN public.suspensionperiodstbl.suspension_name
    IS 'Display name for the suspension (e.g., "Typhoon Odette - December 2021")';

COMMENT ON COLUMN public.suspensionperiodstbl.branch_id
    IS 'Branch affected by suspension. NULL means all branches are affected.';

COMMENT ON COLUMN public.suspensionperiodstbl.reason
    IS 'Reason for suspension: Typhoon, Earthquake, Flood, Holiday, Government Mandate, Other';

COMMENT ON COLUMN public.suspensionperiodstbl.affected_class_ids
    IS 'Array of specific class IDs affected. NULL means all classes in the branch are affected.';

COMMENT ON COLUMN public.suspensionperiodstbl.auto_reschedule
    IS 'Whether to automatically extend class end dates to reschedule suspended sessions';

CREATE TABLE IF NOT EXISTS public.system_settingstbl
(
    setting_id serial NOT NULL,
    setting_key character varying(100) COLLATE pg_catalog."default" NOT NULL,
    setting_value text COLLATE pg_catalog."default",
    setting_type character varying(50) COLLATE pg_catalog."default" NOT NULL DEFAULT 'string'::character varying,
    category character varying(50) COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    branch_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_by integer,
    CONSTRAINT system_settingstbl_pkey PRIMARY KEY (setting_id),
    CONSTRAINT system_settingstbl_unique_key_per_branch UNIQUE (setting_key, branch_id)
);

COMMENT ON TABLE public.system_settingstbl
    IS 'Stores configurable system parameters. Supports per-branch overrides and global defaults (branch_id NULL).';

COMMENT ON COLUMN public.system_settingstbl.setting_key
    IS 'Unique identifier for the setting (e.g., installment_penalty_rate).';

COMMENT ON COLUMN public.system_settingstbl.setting_value
    IS 'Value stored as text; parsed by setting_type.';

COMMENT ON COLUMN public.system_settingstbl.setting_type
    IS 'Type hint for parsing/validation (string, int, number, boolean, json).';

COMMENT ON COLUMN public.system_settingstbl.branch_id
    IS 'NULL = global default. Non-NULL = per-branch override.';

CREATE TABLE IF NOT EXISTS public.userstbl
(
    user_id serial NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" NOT NULL,
    full_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    user_type character varying(50) COLLATE pg_catalog."default",
    gender character varying(50) COLLATE pg_catalog."default",
    date_of_birth date,
    phone_number character varying(50) COLLATE pg_catalog."default",
    branch_id integer,
    level_tag character varying(100) COLLATE pg_catalog."default",
    profile_picture_url character varying(255) COLLATE pg_catalog."default",
    firebase_uid character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT userstbl_pkey PRIMARY KEY (user_id),
    CONSTRAINT userstbl_email_key UNIQUE (email),
    CONSTRAINT userstbl_firebase_uid_key UNIQUE (firebase_uid)
);

ALTER TABLE IF EXISTS public.announcement_readstbl
    ADD CONSTRAINT announcement_readstbl_announcement_id_fkey FOREIGN KEY (announcement_id)
    REFERENCES public.announcementstbl (announcement_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_announcement_read_announcement_id
    ON public.announcement_readstbl(announcement_id);


ALTER TABLE IF EXISTS public.announcement_readstbl
    ADD CONSTRAINT announcement_readstbl_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_announcement_read_user_id
    ON public.announcement_readstbl(user_id);


ALTER TABLE IF EXISTS public.announcementstbl
    ADD CONSTRAINT announcementstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_announcement_branch_id
    ON public.announcementstbl(branch_id);


ALTER TABLE IF EXISTS public.announcementstbl
    ADD CONSTRAINT announcementstbl_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_announcement_created_by
    ON public.announcementstbl(created_by);


ALTER TABLE IF EXISTS public.attendancetbl
    ADD CONSTRAINT attendancetbl_classsession_id_fkey FOREIGN KEY (classsession_id)
    REFERENCES public.classsessionstbl (classsession_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_attendance_classsession_id
    ON public.attendancetbl(classsession_id);


ALTER TABLE IF EXISTS public.attendancetbl
    ADD CONSTRAINT attendancetbl_marked_by_fkey FOREIGN KEY (marked_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_attendance_marked_by
    ON public.attendancetbl(marked_by);


ALTER TABLE IF EXISTS public.attendancetbl
    ADD CONSTRAINT attendancetbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_attendance_student_id
    ON public.attendancetbl(student_id);


ALTER TABLE IF EXISTS public.class_merge_historytbl
    ADD CONSTRAINT class_merge_historytbl_merged_by_fkey FOREIGN KEY (merged_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.class_merge_historytbl
    ADD CONSTRAINT class_merge_historytbl_merged_class_id_fkey FOREIGN KEY (merged_class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_merge_history_merged_class_id
    ON public.class_merge_historytbl(merged_class_id);


ALTER TABLE IF EXISTS public.class_merge_historytbl
    ADD CONSTRAINT class_merge_historytbl_undone_by_fkey FOREIGN KEY (undone_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.classestbl
    ADD CONSTRAINT classestbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_class_branch_id
    ON public.classestbl(branch_id);


ALTER TABLE IF EXISTS public.classestbl
    ADD CONSTRAINT classestbl_program_id_fkey FOREIGN KEY (program_id)
    REFERENCES public.programstbl (program_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_class_program_id
    ON public.classestbl(program_id);


ALTER TABLE IF EXISTS public.classestbl
    ADD CONSTRAINT classestbl_room_id_fkey FOREIGN KEY (room_id)
    REFERENCES public.roomstbl (room_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_class_room_id
    ON public.classestbl(room_id);


ALTER TABLE IF EXISTS public.classestbl
    ADD CONSTRAINT classestbl_teacher_id_fkey FOREIGN KEY (teacher_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_class_teacher_id
    ON public.classestbl(teacher_id);


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_assigned_teacher_id_fkey FOREIGN KEY (assigned_teacher_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_classsession_assigned_teacher_id
    ON public.classsessionstbl(assigned_teacher_id);


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_class_id_fkey FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_classsession_class_id
    ON public.classsessionstbl(class_id);


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_original_teacher_id_fkey FOREIGN KEY (original_teacher_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_phasesessiondetail_id_fkey FOREIGN KEY (phasesessiondetail_id)
    REFERENCES public.phasesessionstbl (phasesessiondetail_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_substitute_teacher_id_fkey FOREIGN KEY (substitute_teacher_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.classsessionstbl
    ADD CONSTRAINT classsessionstbl_suspension_id_fkey FOREIGN KEY (suspension_id)
    REFERENCES public.suspensionperiodstbl (suspension_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_classsession_suspension_id
    ON public.classsessionstbl(suspension_id);


ALTER TABLE IF EXISTS public.classstudentstbl
    ADD CONSTRAINT classstudentstbl_class_id_fkey FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_classstudent_class_id
    ON public.classstudentstbl(class_id);


ALTER TABLE IF EXISTS public.classstudentstbl
    ADD CONSTRAINT classstudentstbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_classstudent_student_id
    ON public.classstudentstbl(student_id);


ALTER TABLE IF EXISTS public.classteacherstbl
    ADD CONSTRAINT fk_class FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.classteacherstbl
    ADD CONSTRAINT fk_teacher FOREIGN KEY (teacher_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS public.guardianstbl
    ADD CONSTRAINT guardianstbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guardian_student_id
    ON public.guardianstbl(student_id);


ALTER TABLE IF EXISTS public.installmentinvoiceprofilestbl
    ADD CONSTRAINT installmentinvoiceprofilestbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoiceprofile_branch_id
    ON public.installmentinvoiceprofilestbl(branch_id);


ALTER TABLE IF EXISTS public.installmentinvoiceprofilestbl
    ADD CONSTRAINT installmentinvoiceprofilestbl_class_id_fkey FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_installmentinvoiceprofile_class_id
    ON public.installmentinvoiceprofilestbl(class_id);


ALTER TABLE IF EXISTS public.installmentinvoiceprofilestbl
    ADD CONSTRAINT installmentinvoiceprofilestbl_downpayment_invoice_id_fkey FOREIGN KEY (downpayment_invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_installmentprofile_downpayment_invoice_id
    ON public.installmentinvoiceprofilestbl(downpayment_invoice_id);


ALTER TABLE IF EXISTS public.installmentinvoiceprofilestbl
    ADD CONSTRAINT installmentinvoiceprofilestbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoiceprofile_package_id
    ON public.installmentinvoiceprofilestbl(package_id);


ALTER TABLE IF EXISTS public.installmentinvoiceprofilestbl
    ADD CONSTRAINT installmentinvoiceprofilestbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoiceprofile_student_id
    ON public.installmentinvoiceprofilestbl(student_id);


ALTER TABLE IF EXISTS public.installmentinvoicestbl
    ADD CONSTRAINT installmentinvoicestbl_installmentinvoiceprofiles_id_fkey FOREIGN KEY (installmentinvoiceprofiles_id)
    REFERENCES public.installmentinvoiceprofilestbl (installmentinvoiceprofiles_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoice_profile_id
    ON public.installmentinvoicestbl(installmentinvoiceprofiles_id);


ALTER TABLE IF EXISTS public.invoiceitemstbl
    ADD CONSTRAINT invoiceitemstbl_invoice_id_fkey FOREIGN KEY (invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoiceitem_invoice_id
    ON public.invoiceitemstbl(invoice_id);


ALTER TABLE IF EXISTS public.invoicestbl
    ADD CONSTRAINT invoicestbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoice_branch_id
    ON public.invoicestbl(branch_id);


ALTER TABLE IF EXISTS public.invoicestbl
    ADD CONSTRAINT invoicestbl_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoice_created_by
    ON public.invoicestbl(created_by);


ALTER TABLE IF EXISTS public.invoicestbl
    ADD CONSTRAINT invoicestbl_installmentinvoiceprofiles_id_fkey FOREIGN KEY (installmentinvoiceprofiles_id)
    REFERENCES public.installmentinvoiceprofilestbl (installmentinvoiceprofiles_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_invoice_installment_profile_id
    ON public.invoicestbl(installmentinvoiceprofiles_id);


ALTER TABLE IF EXISTS public.invoicestbl
    ADD CONSTRAINT invoicestbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_invoice_package_id
    ON public.invoicestbl(package_id);


ALTER TABLE IF EXISTS public.invoicestbl
    ADD CONSTRAINT invoicestbl_promo_id_fkey FOREIGN KEY (promo_id)
    REFERENCES public.promostbl (promo_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_invoice_promo_id
    ON public.invoicestbl(promo_id);


ALTER TABLE IF EXISTS public.invoicestudentstbl
    ADD CONSTRAINT invoicestudentstbl_invoice_id_fkey FOREIGN KEY (invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoicestudent_invoice_id
    ON public.invoicestudentstbl(invoice_id);


ALTER TABLE IF EXISTS public.invoicestudentstbl
    ADD CONSTRAINT invoicestudentstbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invoicestudent_student_id
    ON public.invoicestudentstbl(student_id);


ALTER TABLE IF EXISTS public.merchandiserequestlogtbl
    ADD CONSTRAINT merchandiserequestlogtbl_merchandise_id_fkey FOREIGN KEY (merchandise_id)
    REFERENCES public.merchandisestbl (merchandise_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_merchrequest_merchandise_id
    ON public.merchandiserequestlogtbl(merchandise_id);


ALTER TABLE IF EXISTS public.merchandiserequestlogtbl
    ADD CONSTRAINT merchandiserequestlogtbl_requested_branch_id_fkey FOREIGN KEY (requested_branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_merchrequest_requested_branch
    ON public.merchandiserequestlogtbl(requested_branch_id);


ALTER TABLE IF EXISTS public.merchandiserequestlogtbl
    ADD CONSTRAINT merchandiserequestlogtbl_requested_by_fkey FOREIGN KEY (requested_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_merchrequest_requested_by
    ON public.merchandiserequestlogtbl(requested_by);


ALTER TABLE IF EXISTS public.merchandiserequestlogtbl
    ADD CONSTRAINT merchandiserequestlogtbl_reviewed_by_fkey FOREIGN KEY (reviewed_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.merchandisestbl
    ADD CONSTRAINT merchandisestbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_merchandise_branch_id
    ON public.merchandisestbl(branch_id);


ALTER TABLE IF EXISTS public.packagedetailstbl
    ADD CONSTRAINT packagedetailstbl_merchandise_id_fkey FOREIGN KEY (merchandise_id)
    REFERENCES public.merchandisestbl (merchandise_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_packagedtl_merchandise_id
    ON public.packagedetailstbl(merchandise_id);


ALTER TABLE IF EXISTS public.packagedetailstbl
    ADD CONSTRAINT packagedetailstbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_packagedtl_package_id
    ON public.packagedetailstbl(package_id);


ALTER TABLE IF EXISTS public.packagedetailstbl
    ADD CONSTRAINT packagedetailstbl_pricinglist_id_fkey FOREIGN KEY (pricinglist_id)
    REFERENCES public.pricingliststbl (pricinglist_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_packagedtl_pricinglist_id
    ON public.packagedetailstbl(pricinglist_id);


ALTER TABLE IF EXISTS public.packagestbl
    ADD CONSTRAINT packagestbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_package_branch_id
    ON public.packagestbl(branch_id);


ALTER TABLE IF EXISTS public.paymenttbl
    ADD CONSTRAINT paymenttbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payment_branch_id
    ON public.paymenttbl(branch_id);


ALTER TABLE IF EXISTS public.paymenttbl
    ADD CONSTRAINT paymenttbl_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.paymenttbl
    ADD CONSTRAINT paymenttbl_invoice_id_fkey FOREIGN KEY (invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payment_invoice_id
    ON public.paymenttbl(invoice_id);


ALTER TABLE IF EXISTS public.paymenttbl
    ADD CONSTRAINT paymenttbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payment_student_id
    ON public.paymenttbl(student_id);


ALTER TABLE IF EXISTS public.phasesessionstbl
    ADD CONSTRAINT phasesessionstbl_curriculum_id_fkey FOREIGN KEY (curriculum_id)
    REFERENCES public.curriculumstbl (curriculum_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_phasesession_curriculum_id
    ON public.phasesessionstbl(curriculum_id);


ALTER TABLE IF EXISTS public.pricingliststbl
    ADD CONSTRAINT pricingliststbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_pricinglist_branch_id
    ON public.pricingliststbl(branch_id);


ALTER TABLE IF EXISTS public.programstbl
    ADD CONSTRAINT programstbl_curriculum_id_fkey FOREIGN KEY (curriculum_id)
    REFERENCES public.curriculumstbl (curriculum_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_program_curriculum_id
    ON public.programstbl(curriculum_id);


ALTER TABLE IF EXISTS public.promomerchandisetbl
    ADD CONSTRAINT promomerchandisetbl_merchandise_id_fkey FOREIGN KEY (merchandise_id)
    REFERENCES public.merchandisestbl (merchandise_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promomerchandise_merchandise_id
    ON public.promomerchandisetbl(merchandise_id);


ALTER TABLE IF EXISTS public.promomerchandisetbl
    ADD CONSTRAINT promomerchandisetbl_promo_id_fkey FOREIGN KEY (promo_id)
    REFERENCES public.promostbl (promo_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_promomerchandise_promo_id
    ON public.promomerchandisetbl(promo_id);


ALTER TABLE IF EXISTS public.promopackagestbl
    ADD CONSTRAINT promopackagestbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_promopackage_package_id
    ON public.promopackagestbl(package_id);


ALTER TABLE IF EXISTS public.promopackagestbl
    ADD CONSTRAINT promopackagestbl_promo_id_fkey FOREIGN KEY (promo_id)
    REFERENCES public.promostbl (promo_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_promopackage_promo_id
    ON public.promopackagestbl(promo_id);


ALTER TABLE IF EXISTS public.promostbl
    ADD CONSTRAINT promostbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promo_branch_id
    ON public.promostbl(branch_id);


ALTER TABLE IF EXISTS public.promostbl
    ADD CONSTRAINT promostbl_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.promostbl
    ADD CONSTRAINT promostbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promo_package_id
    ON public.promostbl(package_id);


ALTER TABLE IF EXISTS public.promousagetbl
    ADD CONSTRAINT promousagetbl_invoice_id_fkey FOREIGN KEY (invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promousage_invoice_id
    ON public.promousagetbl(invoice_id);


ALTER TABLE IF EXISTS public.promousagetbl
    ADD CONSTRAINT promousagetbl_promo_id_fkey FOREIGN KEY (promo_id)
    REFERENCES public.promostbl (promo_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promousage_promo_id
    ON public.promousagetbl(promo_id);


ALTER TABLE IF EXISTS public.promousagetbl
    ADD CONSTRAINT promousagetbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_promousage_student_id
    ON public.promousagetbl(student_id);


ALTER TABLE IF EXISTS public.referralstbl
    ADD CONSTRAINT referralstbl_referred_student_id_fkey FOREIGN KEY (referred_student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS referralstbl_unique_referred
    ON public.referralstbl(referred_student_id);


ALTER TABLE IF EXISTS public.referralstbl
    ADD CONSTRAINT referralstbl_referrer_student_id_fkey FOREIGN KEY (referrer_student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_referral_referrer
    ON public.referralstbl(referrer_student_id);


ALTER TABLE IF EXISTS public.reservedstudentstbl
    ADD CONSTRAINT reservedstudentstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservedstudent_branch_id
    ON public.reservedstudentstbl(branch_id);


ALTER TABLE IF EXISTS public.reservedstudentstbl
    ADD CONSTRAINT reservedstudentstbl_class_id_fkey FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservedstudent_class_id
    ON public.reservedstudentstbl(class_id);


ALTER TABLE IF EXISTS public.reservedstudentstbl
    ADD CONSTRAINT reservedstudentstbl_invoice_id_fkey FOREIGN KEY (invoice_id)
    REFERENCES public.invoicestbl (invoice_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.reservedstudentstbl
    ADD CONSTRAINT reservedstudentstbl_package_id_fkey FOREIGN KEY (package_id)
    REFERENCES public.packagestbl (package_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.reservedstudentstbl
    ADD CONSTRAINT reservedstudentstbl_student_id_fkey FOREIGN KEY (student_id)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservedstudent_student_id
    ON public.reservedstudentstbl(student_id);


ALTER TABLE IF EXISTS public.roomschedtbl
    ADD CONSTRAINT roomschedtbl_class_id_fkey FOREIGN KEY (class_id)
    REFERENCES public.classestbl (class_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.roomschedtbl
    ADD CONSTRAINT roomschedtbl_room_id_fkey FOREIGN KEY (room_id)
    REFERENCES public.roomstbl (room_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.roomstbl
    ADD CONSTRAINT roomstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_room_branch_id
    ON public.roomstbl(branch_id);


ALTER TABLE IF EXISTS public.suspensionperiodstbl
    ADD CONSTRAINT suspensionperiodstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_suspension_branch_id
    ON public.suspensionperiodstbl(branch_id);


ALTER TABLE IF EXISTS public.suspensionperiodstbl
    ADD CONSTRAINT suspensionperiodstbl_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_suspension_created_by
    ON public.suspensionperiodstbl(created_by);


ALTER TABLE IF EXISTS public.system_settingstbl
    ADD CONSTRAINT system_settingstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_system_settings_branch_id
    ON public.system_settingstbl(branch_id);


ALTER TABLE IF EXISTS public.system_settingstbl
    ADD CONSTRAINT system_settingstbl_updated_by_fkey FOREIGN KEY (updated_by)
    REFERENCES public.userstbl (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS public.userstbl
    ADD CONSTRAINT userstbl_branch_id_fkey FOREIGN KEY (branch_id)
    REFERENCES public.branchestbl (branch_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_user_branch_id
    ON public.userstbl(branch_id);

END;